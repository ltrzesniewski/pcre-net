<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text.RegularExpressions" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<#

var functions = ParseFunctions(
    """
    int get_error_message(int errorCode, void* errorBuffer, uint bufferSize) no-gc;
    void compile(Native.compile_input* input, Native.compile_result* result);
    void code_free(void* code);
    int pattern_info(void* code, uint key, void* data) no-gc;
    int config(uint key, void* data) no-gc;
    void match(Native.match_input* input, Native.match_result* result);
    void buffer_match(Native.buffer_match_input* input, Native.match_result* result);
    void dfa_match(Native.dfa_match_input* input, Native.match_result* result);
    void substitute(Native.substitute_input* input, Native.substitute_result* result);
    void substitute_result_free(Native.substitute_result* result);
    void* create_match_buffer(Native.match_buffer_info* info);
    void free_match_buffer(void* buffer);
    uint get_callout_count(void* code) no-gc;
    void get_callouts(void* code, Native.pcre2_callout_enumerate_block* data) no-gc;
    void* jit_stack_create(uint startSize, uint maxSize);
    void jit_stack_free(void* stack);
    int convert(Native.convert_input* input, Native.convert_result* result);
    void convert_result_free(void* str);
    """
).ToList();

const string libName = "PCRE.NET.Native";

var platforms = new[] {
    new PlatformDef("Win", libName + ".dll"),
    new PlatformDef("Win32", libName + ".x86.dll"),
    new PlatformDef("Win64", libName + ".x64.dll"),
    new PlatformDef("Linux", libName + ".so"),
    new PlatformDef("OSX", libName + ".dylib")
};

#>
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Runtime.InteropServices;
using System.Security;

#nullable enable
#pragma warning disable CA5392

namespace PCRE.Internal;

internal unsafe partial interface INative
{
<# foreach (var func in functions) { #>
    <#= func.ReturnType #> <#= func.Name #>(<#= string.Join(", ", func.Parameters.Select(p => p.GetDeclaration())) #>);
<# } #>

}
<# foreach (var bit in new[] { 8, 16 }) { #>

internal readonly unsafe partial struct NativeStruct<#= bit #>Bit
{
<# foreach (var func in functions) { #>
    public readonly <#= func.ReturnType #> <#= func.Name #>(<#= string.Join(", ", func.Parameters.Select(p => p.GetDeclaration())) #>)
        => Native<#= bit #>Bit.<#= func.Name #>(<#= string.Join(", ", func.Parameters.Select(p => $"{p.Modifier}{p.Name}")) #>);

<# } #>
}

internal unsafe partial class Native<#= bit #>Bit
{
#if !NET
    private static readonly LibImpl _impl = GetLibImpl();

    private static LibImpl GetLibImpl()
    {
        try
        {
            var impl = RuntimeInformation.IsOSPlatform(OSPlatform.Windows)
                ? new WinImpl()
                : RuntimeInformation.IsOSPlatform(OSPlatform.Linux)
                    ? new LinuxImpl()
                    : RuntimeInformation.IsOSPlatform(OSPlatform.OSX)
                        ? (LibImpl)new OSXImpl()
                        : throw new PlatformNotSupportedException();

            impl.get_error_message(0, null, 0);
            return impl;
        }
        catch (DllNotFoundException) when (RuntimeInformation.IsOSPlatform(OSPlatform.Windows))
        {
            // Used in the .NET Framework
            return Environment.Is64BitProcess
                ? new Win64Impl()
                : new Win32Impl();
        }
    }
#endif

#if NET

<# foreach (var func in functions) { #>
<# if (func.SuppressGCTransition) { #>
    [SuppressGCTransition]
<# } #>
    [DllImport("<#= libName #>", EntryPoint = "pcrenet_<#= func.Name #>_<#= bit #>", CallingConvention = CallingConvention.Cdecl)]
    public static extern <#= func.ReturnType #> <#= func.Name #>(<#= string.Join(", ", func.Parameters.Select(p => p.GetDeclaration())) #>);

<# } #>
#else

<# foreach (var func in functions) { #>
    public static <#= func.GetDeclaration() #>
        => _impl.<#= func.Name #>(<#= string.Join(", ", func.Parameters.Select(p => $"{p.Modifier}{p.Name}")) #>);

<# } #>
    private abstract class LibImpl
    {
<# foreach (var func in functions) { #>
        public abstract <#= func.GetDeclaration() #>;
<# } #>
    }

<# foreach (var platform in platforms) { #>
    [SuppressUnmanagedCodeSecurity]
    private sealed class <#= platform.Name #>Impl : LibImpl
    {
<# foreach (var func in functions) { #>
        public override <#= func.GetDeclaration() #>
            => pcrenet_<#= func.Name #>(<#= string.Join(", ", func.Parameters.Select(p => $"{p.Modifier}{p.Name}")) #>);

        [DllImport("<#= platform.LibName #>", EntryPoint = "pcrenet_<#= func.Name #>_<#= bit #>", CallingConvention = CallingConvention.Cdecl)]
        private static extern <#= func.ReturnType #> pcrenet_<#= func.Name #>(<#= string.Join(", ", func.Parameters.Select(p => p.GetDeclaration())) #>);

<# } #>
    }

<# } #>
#endif
}
<# } #>
<#+

private static IEnumerable<FuncDef> ParseFunctions(string functions)
{
    var functionsRe = new Regex(
        """
        \G \s*
        (?<returnType>\S+) \s+ (?<funcName>\w+) \s* \(
        (?: \s*
            (?<paramModifier> (?: (?:in|ref|out) \s+)? )
            (?<paramType>\S+) \s+ (?<paramName>\w+) \s*
            (?(?=,),|(?=\)))
        )*
        \) \s*
        (?<nogc>no-gc)?
        \s* ;
        """,
        RegexOptions.IgnorePatternWhitespace | RegexOptions.CultureInvariant
    );

    foreach (Match match in functionsRe.Matches(functions))
    {
        var def = new FuncDef
        {
            ReturnType = match.Groups["returnType"].Value,
            Name = match.Groups["funcName"].Value,
            SuppressGCTransition = match.Groups["nogc"].Success
        };

        var paramTypes = match.Groups["paramType"].Captures.Cast<Capture>().Select(i => i.Value).ToList();
        var paramNames = match.Groups["paramName"].Captures.Cast<Capture>().Select(i => i.Value).ToList();
        var paramModifiers = match.Groups["paramModifier"].Captures.Cast<Capture>().Select(i => i.Value).ToList();

        for (var i = 0; i < paramNames.Count; ++i)
        {
            def.Parameters.Add(new FuncParamDef
            {
                Type = paramTypes[i],
                Name = paramNames[i],
                Modifier = paramModifiers[i]
            });
        }

        yield return def;
    }
}

private class FuncDef
{
    public string ReturnType;
    public string Name;
    public readonly List<FuncParamDef> Parameters = new();
    public bool SuppressGCTransition;

    public string GetDeclaration()
        => $"{ReturnType} {Name}({string.Join(", ", Parameters.Select(p => p.GetDeclaration()))})";
}

private class FuncParamDef
{
    public string Type;
    public string Name;
    public string Modifier;

    public string GetDeclaration()
        => $"{Modifier}{Type} {Name}";
}

private class PlatformDef(string name, string libName)
{
    public readonly string Name = name;
    public readonly string LibName = libName;
}

#>
